rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

   
    // Helpers
   
    function isValidTimezone(tz) {
      return tz is string
        && tz.size() > 0
        && tz.size() < 100
        && tz.matches('^[A-Za-z_+\\-]+(?:\\/[A-Za-z_+\\-]+)*$');
    }

    function isValidTimeToken(t) {
      return t is string
        && t.matches('^\\d{1,2}:\\d{2}$')
        && (int(t.split(':')[0]) >= 0 && int(t.split(':')[0]) <= 23)
        && (int(t.split(':')[1]) >= 0 && int(t.split(':')[1]) <= 59);
    }

    function isValidWeekDays(wd) {
      return wd is list
        && wd.size() > 0
        && wd.size() <= 7
        && wd[0] is int
        && wd[0] >= 1
        && wd[0] <= 7;
    }

    function isValidSchedule(s) {
      let timeCandidate = (
        ('localTime' in s) ? s.localTime :
        (('timeOfDay' in s) ? s.timeOfDay :
        (('time' in s) ? s.time :
        (('timeLocal' in s) ? s.timeLocal : null)))
      );
      let localDateOk = !('localDate' in s) || (s.localDate is string && s.localDate.matches('^\\d{4}-\\d{2}-\\d{2}$'));
      let dateOk = !('date' in s) || (s.date is string && s.date.matches('^\\d{4}-\\d{2}-\\d{2}$'));
      let daysOfWeekOk = !('daysOfWeek' in s) || isValidWeekDays(s.daysOfWeek);
      let weekDaysOk = !('weekDays' in s) || isValidWeekDays(s.weekDays);

      return s is map
        && ('timezone' in s) && isValidTimezone(s.timezone)
        && (timeCandidate is string) && isValidTimeToken(timeCandidate)
        && localDateOk
        && dateOk
        && daysOfWeekOk
        && weekDaysOk;
    }

   
    // Users collection
   
    match /users/{userId} {
      allow read: if request.auth != null && request.auth.uid == userId;
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.email is string
        && request.resource.data.email.size() > 3
        && !('isAdmin' in request.resource.data);

      allow update: if request.auth != null
        && request.auth.uid == userId
        && (!('timezone' in request.resource.data) || isValidTimezone(request.resource.data.timezone))
        && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
        && (!('isAdmin' in request.resource.data) || request.resource.data.isAdmin == resource.data.isAdmin);

      allow delete: if request.auth != null && request.auth.uid == userId;
    }

    match /users/{userId}/userPrefs {
      allow read, write: if request.auth != null && request.auth.uid == userId;
    }

   
    // Idempotency mapping
   
    match /users/{userId}/reminderIdempotency/{key} {
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.reminderId is string
        && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == request.time)
        && (!('expiresAt' in request.resource.data) || request.resource.data.expiresAt is timestamp)
        && request.resource.data.keys().hasOnly(['reminderId', 'createdAt', 'expiresAt']);

      allow update: if false;
      allow read, delete: if request.auth != null && request.auth.uid == userId;
    }

   
    // Per-user reminders (THE CORE LOGIC)
   
    match /users/{userId}/reminders/{reminderId} {

      // CREATE: Strictly allow Intent, Disallow System fields
      allow create: if request.auth != null
        && request.auth.uid == userId
        && request.resource.data.ownerId == request.auth.uid
        && request.resource.data.reminderType in ['ai', 'simple']
        && request.resource.data.frequency in ['one_time', 'daily', 'weekly']
        && isValidSchedule(request.resource.data.schedule)
        // Ensure system fields are NOT present in the payload
        && !('enabled' in request.resource.data)
        && !('nextRunAtUTC' in request.resource.data)
        && !('createdAt' in request.resource.data)
        && !('updatedAt' in request.resource.data)
        && !('deletedAt' in request.resource.data)
        && !('meta' in request.resource.data)
        && (
          // AI Intent Branch
          (
            request.resource.data.reminderType == 'ai'
            && request.resource.data.keys().hasOnly(['ownerId', 'reminderType', 'content', 'frequency', 'schedule'])
            && request.resource.data.content is map
            && request.resource.data.content.aiPrompt is string
            && request.resource.data.content.aiPrompt.size() <= 2000
          )
          ||
          // Simple Intent Branch
          (
            request.resource.data.reminderType == 'simple'
            && request.resource.data.keys().hasOnly(['ownerId', 'reminderType', 'content', 'frequency', 'schedule'])
            && request.resource.data.content is map
            && request.resource.data.content.message is string
          )
        );

      // READ ONLY - NO DELETE ALLOWED (Soft Delete Architecture)
      allow read: if request.auth != null && request.auth.uid == userId;

      // UPDATE: Allow intent changes, keep system fields immutable for Client
      allow update: if request.auth != null
        && request.auth.uid == userId
        && ( !('ownerId' in request.resource.data) || request.resource.data.ownerId == resource.data.ownerId )
        && (!('schedule' in request.resource.data) || isValidSchedule(request.resource.data.schedule))
        && (!('createdAt' in request.resource.data) || request.resource.data.createdAt == resource.data.createdAt)
        // DISALLOW client from toggling enabled/scheduling via update
        && (!('nextRunAtUTC' in request.resource.data) || request.resource.data.nextRunAtUTC == resource.data.nextRunAtUTC)
        && (!('enabled' in request.resource.data) || request.resource.data.enabled == resource.data.enabled)
        && (!('deletedAt' in request.resource.data) || request.resource.data.deletedAt == resource.data.deletedAt)
        && (
          !('reminderType' in request.resource.data) ||
          request.resource.data.reminderType == resource.data.reminderType
        );
    }

   
    // Recompute queue
   
    match /recompute_queue/{jobId} {
      allow read: if request.auth != null && request.auth.uid == jobId;
      allow create: if request.auth != null
        && request.auth.uid == jobId
        && request.resource.data.uid == request.auth.uid
        && request.resource.data.requestedAt is timestamp
        && request.resource.data.newTimezone is string
        && request.resource.data.status is string
        && request.resource.data.requester is string
        && request.resource.data.keys().hasOnly(['uid','newTimezone','requestedAt','status','requester','error']);
      allow update, delete: if false;
    }

   
    // Draft interaction tracking
   
    match /users/{userId}/draftInteractions/{draftId} {
      allow read, create, update: if request.auth != null
        && request.auth.uid == userId;

      allow delete: if false;
    }

   
    // Backend-only / Default Deny
   
    match /users/{uid}/executions/{executionId} {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow write: if false;
    }

    match /users/{uid}/drafts/{draftId} {
      allow read: if request.auth != null && request.auth.uid == uid;
      allow write: if false;
    }

    match /users/{uid}/aiDaily/{dateKey} { allow read, write: if false; }
    match /system/aiUsage/{document=**} { allow read, write: if false; }
    match /{document=**} { allow read, write: if false; }
  }
} 